"# binary_ex" 
もちろんです。ビット演算が苦手な状態から、以前のようなビットDP問題が解けるようになるまでをサポートする課題集を作成しました。各レベルを順番にクリアしていくことで、自然と実力がつくように構成してあります。

---

### ## ビット演算を極めるための課題集 💪

ビット演算は、コンピュータの気持ちになって考える最初のステップです。焦らず、一つ一つの課題を楽しみながら解いていきましょう！

### ### レベル1：基礎の基礎 🛠️

まずは、ビット演算子が何をしているのかを体感的に理解するための課題です。

**課題1-1：AND `&` と OR `|`**
整数 `A = 13` (2進数: `1101`) と `B = 10` (2進数: `1010`) があります。
`A & B` と `A | B` の結果はそれぞれいくつになりますか？紙とペンで2進数の筆算をしてみて、Pythonの計算結果と合うか確かめてください。

**課題1-2：XOR `^`**
`A = 13` と `B = 10` の `A ^ B` はいくつになりますか？XORは「排他的論理和」と呼ばれ、「2つのビットが異なれば1、同じなら0」になる演算です。これも筆算で確かめてみましょう。

**課題1-3：ビットシフト `<<`, `>>`**
`N = 12` (2進数: `1100`) があります。`N << 1` と `N >> 1` の結果はいくつになりますか？
それぞれが「2倍」「1/2倍（切り捨て）」とほぼ同じ意味になることを確認してください。

---

### ### レベル2：基本的なビット操作テクニック 💡

特定のビットを操作する、ビット演算の「イディオム（定型句）」を学びます。これができると、一気にやれることが増えます。

**課題2-1：特定のビットが立っているか調べる**
整数 `N` と整数 `k` が与えられます。`N` の右から `k` 番目（0-indexed）のビットが `1` かどうかを判定してください。
-   **ヒント**: `1` を `k` ビット左にシフトした数 `(1 << k)` と `N` の AND を取るとどうなるでしょう？

**課題2-2：特定のビットを立てる**
整数 `N` と整数 `k` が与えられます。`N` の右から `k` 番目のビットを `1` に変更した数を出力してください。（元々 `1` ならそのままでOK）
-   **ヒント**: `(1 << k)` と `N` の OR を取ります。

**課題2-3：特定のビットを降ろす**
整数 `N` と整数 `k` が与えられます。`N` の右から `k` 番目のビットを `0` に変更した数を出力してください。（元々 `0` ならそのままでOK）
-   **ヒント**: `(1 << k)` のビットを反転させたもの (`~(1 << k)`) と `N` の AND を取ります。

**課題2-4：特定のビットを反転させる**
整数 `N` と整数 `k` が与えられます。`N` の右から `k` 番目のビットを反転（`0`なら`1`に、`1`なら`0`に）させた数を出力してください。
-   **ヒント**: XOR の「異なれば1、同じなら0」という性質が使えます。`N ^ (1 << k)` を試してみましょう。

---

### ### レベル3：応用問題 🧠

基本的なテクニックを使い、よくある問題を解いてみましょう。

**課題3-1：立っているビットの数を数える**
整数 `N` が与えられます。`N` を2進数で表現したときに `1` になっているビットの数を数えてください。
-   **ヒント**: `N` が `0` になるまで、「一番右のビットが `1` かチェック → `N` を1ビット右にシフト」を繰り返します。

**課題3-2：2のべき乗か判定する**
整数 `N` が与えられます。`N` が2のべき乗（1, 2, 4, 8, ...）であるかどうかを判定してください。ただし `N > 0` とします。
-   **ヒント**: 2のべき乗の数は、2進数で表すと `1` が一つしかありません（例: 8 → `1000`）。`N` と `N-1` の AND を取ると、面白いことが起こります。

**課題3-3：ユニークな数字を見つける**
全ての要素が2回ずつ現れる配列の中に、1つだけ1回しか現れない要素があります。そのユニークな要素を見つけてください。
-   例: `[4, 1, 2, 1, 2]` → `4`
-   **ヒント**: 同じ数同士をXORすると `0` になります (`A ^ A = 0`)。また、 어떤数と `0` をXORすると元の数になります (`A ^ 0 = A`)。配列の全要素をXORするとどうなるでしょうか？

---

### ### レベル4：ビットDPへの道 🌉

いよいよ、ご質問いただいた問題のような、集合をビットで管理する考え方に入ります。

**課題4-1：部分集合の列挙**
`N`が与えられます。`{0, 1, ..., N-1}` という集合の全ての部分集合を列挙してください。
-   **考え方**: 部分集合は `$2^N$`個あります。`0` から `$2^N-1$` までの整数をループさせ、各整数の2進数表現を部分集合と見なします。例えば`N=3`のとき、`5` (2進数: `101`) は集合`{0, 2}`に対応します。

**課題4-2：ある集合の部分集合を列挙する (発展)**
ある集合を表すビットマスク `mask` が与えられます。`mask` の部分集合（サブマスク）を全て列挙してください。
-   **ヒント**: `submask = mask` から始め、`submask = (submask - 1) & mask` という処理を `submask` が `0` になるまで繰り返すと、全てのサブマスクを列挙できます。これは競技プログラミングで時々使うテクニックです。

---

### ### レベル5：ビットDP実践 🚀

最後の仕上げです。以前の質問と同レベルの典型的なビットDP問題です。

**課題：巡回セールスマン問題 (小規模)**
`N`個の都市（0からN-1）と、各都市間の移動コストが `cost[i][j]` として与えられます。都市0からスタートし、全ての都市を一度ずつ訪れて、最後に都市0に戻ってくるような最短経路の長さを求めてください。`N`は18以下とします。
-   **考え方**:
    -   `dp[mask][i]` を「既に訪れた都市の集合が`mask`で、現在いる都市が`i`であるときの最短経路長」と定義します。
    -   `dp[1][0] = 0` で初期化します（`mask=1`は`00...01`で、都市0のみを訪れた状態）。
    -   `dp`テーブルを `mask` の小さい順に埋めていきます。
    -   `dp[mask][i]` を計算するには、`mask` に含まれる都市 `j` (`j != i`) から都市 `i` に来たと考えて、`dp[prev_mask][j] + cost[j][i]` の最小値を探します。ここで `prev_mask` は `mask` から都市 `i` を除いたものです。

この最終問題を自力で解くことができれば、ビット演算とビットDPの基礎は完全にマスターしたと言えるでしょう。頑張ってください！